# ----------------------------------THE DESIGN OF THE MAPLET SCREEN---------------------
with(Maplets[Elements]):
HCC:=Maplet(Window('title'="HEAT CONDUCTIVITY CONTROL",["WITH THIS APPLICATION THE CONDUCTIVITY COEFFICIENT OF A ONE-DIMENSIONAL OBJECT, APPROXIMATING THE TEMPRATURE OF THE OBJECT TO A TARGET TEMPRETURE AT A CERTAIN FINAL TIME, IS CONTROLLED. ",[["l",TextField[l](3)],["T",TextField[T](3)],["f(x,t)",TextField[f](15)],["phi(x)",TextField[ph](5)]],[["k(0)",TextField[k0](3)],["g0(t)",TextField[g0](10)],["k(l)",TextField[kl](3)],["g1(t)",TextField[g1](10)],["mu(x)",TextField[mu](10)]],[["alpha",TextField[alpha](3)],["kaplus(x)",TextField[kaplus](5)],["N",TextField[N](3)],["kstart(x)",TextField[kstart](3)],["beta",TextField[beta](3)],["eps",TextField[eps](3)]] ,[Button("Calculate the Control",Evaluate('kutu'=ms(N,l,alpha,T,ph,f,g0,g1,mu,kaplus,k0,kl,kstart,beta,eps))),[TextBox['kutu'](30..30)],Button("Draw the Control",Evaluate('Draw'='plot(kutu,x=0..l)')),Plotter['Draw'](),[[Button("Distance to
Target",Evaluate('kutu2'=ms8(N,l,alpha,T,ph,f,g0,g1,mu,kaplus,k0,kl,kstart,beta,eps))),TextField['kutu2'](12)],[Button("Approximation to kaplus",Evaluate('kutu3'='evalf(int((kutu-kaplus)^2,x=0..l))')),TextField['kutu3'](12)]]],Button("Shutdown",Shutdown())])):
# -------------------------PROCEDURE FOR CALCULATION OF THE CONTROL FUNCTION-----------
with(inttrans):
with(linalg):
ms:=proc(N,l,alpha,T,ph,f,g0,g1,mu,kaplus,k0,kl,kstart,beta,eps):
with(inttrans):
with(linalg):
w:=simplify(x^2/2*g1/(l*kl)+(x^2/2-x*l)*g0/(l*k0)):
phdal:=ph-subs(t=0,w):
fdal:=simplify(f-diff(w,t)+diff(kaplus*diff(w,x),x)):
# ---------------------------------Solution of the Heat Problem------------------------------------
dp:=proc(ka)
with(inttrans):
with(linalg):
phi:=Vector(1..N):
phi[1]:=1/sqrt(l):
for i from 2 to N do
phi[i]:=evalf(sqrt(2/l)*cos((i-1)*Pi*x/l)):
od:
K:=Array(1..N,1..N):
for j from 1 to N do
for k from 1 to N do
K[j,k]:=evalf(-int(ka*diff(phi[k],x$2)*phi[j],x=0..l)):
od:
od:
F:=Vector(1..N):
for n from 1 to N do
F[n]:=evalf(int(fdal*phi[n],x=0..l)):
od:
A:=Vector(1..N):
for m from 1 to N do
A[m]:=evalf(int(phdal*phi[m],x=0..l)):
od:
KL:=Matrix(1..N,1..N):
for j1 from 1 to N do
for k1 from 1 to N do
if (j1=k1) then KL[j1,k1]:=s+K[j1,k1] else KL[j1,k1]:=K[j1,k1] fi:
od:
od:
FL:=Vector(1..N):
for i1 from 1 to N do
FL[i1]:=evalf(laplace(F[i1],t,s));
od:
S:=Vector(1..N):
for i2 from 1 to N do
S[i2]:=(A[i2]+FL[i2]);
od:
C:=Vector(1..N):
C:=evalm(inverse(KL)&*S):
c:=Vector(1..N):
for i3 from 1 to N do
c[i3]:=evalf(invlaplace(C[i3],s,t)):
od:
v:=evalf(add(c[n1]*phi[n1],n1=1..N)):
uyak:=v+w;
end:
# ---------------------------------Solution of the Adjoint Problem------------------------------------
ap:=proc(ka)
with(inttrans):
with(linalg):
utau:=evalf(subs(t=T-tau,dp(ka))):
phe:=evalf(2*(subs(tau=0,utau)-mu));
phie:=Vector(1..N):
phie[1]:=1/sqrt(l):
for i4 from 2 to N do
phie[i4]:=evalf(sqrt(2/l)*cos((i4-1)*Pi*x/l)):
od:
Kc:=Array(1..N,1..N):
for j2 from 1 to N do
for k2 from 1 to N do
Kc[j2,k2]:=evalf(-int(ka*diff(phie[k2],x$2)*phie[j2],x=0..l)):
od:
od:
Fc:=Vector(1..N):
for m1 from 1 to N do
Fc[m1]:=0:
od:
Ac:=Vector(1..N):
for cm1 from 1 to N do
Ac[cm1]:=evalf(int(phe*phie[cm1],x=0..l)):
od:
KLC:=Matrix(1..N,1..N):
for cj1 from 1 to N do
for ck1 from 1 to N do
if (cj1=ck1) then KLC[cj1,ck1]:=s+Kc[cj1,ck1] else KLC[cj1,ck1]:=Kc[cj1,ck1] fi:
od:
od:
FLC:=Vector(1..N):
for ci1 from 1 to N do
FLC[ci1]:=evalf(laplace(Fc[ci1],tau,s));
od:
Sc:=Vector(1..N):
for ci2 from 1 to N do
Sc[ci2]:=(Ac[ci2]+FLC[ci2]);
od:
CC:=Vector(1..N):
CC:=evalm(inverse(KLC)&*Sc):
cc:=Vector(1..N):
for ci3 from 1 to N do
cc[ci3]:=evalf((invlaplace(CC[ci3],s,tau))):
od:
ve:=evalf(add(cc[cn]*phie[cn],cn=1..N)):
eta:=evalf(subs(tau=T-t,ve));
end:
# ---------------------------------Calculation of the Gradient----------------------------------
Türev:=proc(alpha,ka)
Türe:=simplify(evalf(-int(diff(dp(ka),x)*diff(ap(ka),x),t=0..T)+2*alpha*(ka-kaplus)));
end:
# ----------------------------Calculation of the Cost Functional--------------------------------
Jka:=proc(ka)
IJ1:=evalf(int((subs(t=T,dp(ka))-mu)^2,x=0..l));
end:
Sta:=proc(ka)
IJ2:=simplify(evalf((int((ka-kaplus)^2,x=0..l))));
end:
II:=proc(ka)
IJ:=simplify(evalf(Jka(ka)+alpha*Sta(ka))):
end:# 
# -----------------------------------Minimizing Process--------------------------------------------
a[0]:=kstart:
ka[0]:=kstart:
sayı:=0:
for im from 0 to 60 do
a[im+1]:=simplify(evalf(ka[im-sayı]-beta*Türev(alpha,ka[im-sayı]))): 
fark:=evalf(II(ka[im-sayı])-II(a[im+1])): 
if(fark>0 and fark<eps) then break elif (fark>0) then 
j:=im+1: ka[j-sayı]:=a[im+1]:   elif(fark<=0) then  sayı:=sayı+1: beta:=beta/(1.2): ka[im-sayı+2]:=ka[im-sayı+1]:   else fi:
od:
optcont:=a[im+1]:
end:
# -------------------------END OF THE PROCEDURE FOR CALCULATION OF THE CONTROL FUNCTION-----------
# ------PROCEDURE FOR CALCULATION OF THE DISTANCE TO THE TARGET FUNCTION-----------
ms8:=proc(N,l,alpha,T,ph,f,g0,g1,mu,kaplus,k0,kl,kstart,beta,eps):
with(inttrans):
with(linalg):
w8:=simplify(x^2/2*g1/(l*kl)+(x^2/2-x*l)*g0/(l*k0)):
phdal8:=ph-subs(t=0,w8):
fdal8:=simplify(f-diff(w8,t)+diff(kaplus*diff(w8,x),x)):
phi8:=Vector(1..N):
phi8[1]:=1/sqrt(l):
for i8 from 2 to N do
phi8[i8]:=evalf(sqrt(2/l)*cos((i8-1)*Pi*x/l)):
od:
K8:=Array(1..N,1..N):
for j8 from 1 to N do
for k8 from 1 to N do
K8[j8,k8]:=evalf(-int(ms(N,l,alpha,T,ph,f,g0,g1,mu,kaplus,k0,kl,kstart,beta,eps)*diff(phi8[k8],x$2)*phi8[j8],x=0..l)):
od:
od:
F8:=Vector(1..N):
for m28 from 1 to N do
F8[m28]:=evalf(int(fdal8*phi8[m28],x=0..l)):
od:
A8:=Vector(1..N):
for m8 from 1 to N do
A8[m8]:=evalf(int(phdal8*phi8[m8],x=0..l)):
od:
KL8:=Matrix(1..N,1..N):
for j18 from 1 to N do
for k18 from 1 to N do
if (j18=k18) then KL8[j18,k18]:=s+K8[j18,k18] else KL8[j18,k18]:=K8[j18,k18] fi:
od:
od:
FL8:=Vector(1..N):
for i148 from 1 to N do
FL8[i148]:=evalf(laplace(F8[i148],t,s));
od:
S8:=Vector(1..N):
for i48 from 1 to N do
S8[i48]:=(A8[i48]+FL8[i48]);
od:
C8:=Vector(1..N):
C8:=evalm(inverse(KL8)&*S8):
c8:=Vector(1..N):
for i58 from 1 to N do
c8[i58]:=evalf(invlaplace(C8[i58],s,t)):
od:
v8:=evalf(add(c8[n8]*phi8[n8],n8=1..N)):
uyak8:=v8+w8;
IJ18:=evalf(int((subs(t=T,uyak8)-mu)^2,x=0..l));
end:
# ------END OF THE PROCEDURE FOR CALCULATION OF THE DISTANCE TO THE TARGET FUNCTION-----------
Maplets[Display](HCC):






